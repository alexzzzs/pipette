searchData={"items":[{"type":"module","title":"PipetteElixir","doc":"Pipeline-first utilities: control, result, deep paths, bounded parallelism.","ref":"PipetteElixir.html"},{"type":"function","title":"PipetteElixir.and_then/2","doc":"See  PipetteElixir.Result.bind/2 .","ref":"PipetteElixir.html#and_then/2"},{"type":"function","title":"PipetteElixir.bind/2","doc":"See  PipetteElixir.Result.bind/2 .","ref":"PipetteElixir.html#bind/2"},{"type":"function","title":"PipetteElixir.dbg_when/2","doc":"See  PipetteElixir.Control.dbg_when/2 .","ref":"PipetteElixir.html#dbg_when/2"},{"type":"function","title":"PipetteElixir.dig_get/3","doc":"See  PipetteElixir.Deep.dig_get/3 .","ref":"PipetteElixir.html#dig_get/3"},{"type":"function","title":"PipetteElixir.dig_pop/2","doc":"See  PipetteElixir.Deep.dig_pop/2 .","ref":"PipetteElixir.html#dig_pop/2"},{"type":"function","title":"PipetteElixir.dig_put/3","doc":"See  PipetteElixir.Deep.dig_put/3 .","ref":"PipetteElixir.html#dig_put/3"},{"type":"function","title":"PipetteElixir.dig_update/3","doc":"See  PipetteElixir.Deep.dig_update/3 .","ref":"PipetteElixir.html#dig_update/3"},{"type":"function","title":"PipetteElixir.do_tap/2","doc":"See  PipetteElixir.Control.do_tap/2 .","ref":"PipetteElixir.html#do_tap/2"},{"type":"function","title":"PipetteElixir.error/1","doc":"See  PipetteElixir.Result.error/1 .","ref":"PipetteElixir.html#error/1"},{"type":"function","title":"PipetteElixir.map_error/2","doc":"See  PipetteElixir.Result.map_error/2 .","ref":"PipetteElixir.html#map_error/2"},{"type":"function","title":"PipetteElixir.map_ok/2","doc":"See  PipetteElixir.Result.map_ok/2 .","ref":"PipetteElixir.html#map_ok/2"},{"type":"function","title":"PipetteElixir.ok/1","doc":"See  PipetteElixir.Result.ok/1 .","ref":"PipetteElixir.html#ok/1"},{"type":"function","title":"PipetteElixir.pfilter/3","doc":"See  PipetteElixir.Parallel.pfilter/3 .","ref":"PipetteElixir.html#pfilter/3"},{"type":"macro","title":"PipetteElixir.pipe_case/2","doc":"","ref":"PipetteElixir.html#pipe_case/2"},{"type":"function","title":"PipetteElixir.pipe_unless/3","doc":"See  PipetteElixir.Control.pipe_unless/3 .","ref":"PipetteElixir.html#pipe_unless/3"},{"type":"function","title":"PipetteElixir.pipe_when/3","doc":"See  PipetteElixir.Control.pipe_when/3 .","ref":"PipetteElixir.html#pipe_when/3"},{"type":"function","title":"PipetteElixir.pmap/3","doc":"See  PipetteElixir.Parallel.pmap/3 .","ref":"PipetteElixir.html#pmap/3"},{"type":"function","title":"PipetteElixir.pmap_reduce/5","doc":"See  PipetteElixir.Parallel.pmap_reduce/5 .","ref":"PipetteElixir.html#pmap_reduce/5"},{"type":"function","title":"PipetteElixir.presence/2","doc":"See  PipetteElixir.Result.presence/2 .","ref":"PipetteElixir.html#presence/2"},{"type":"function","title":"PipetteElixir.sequence/1","doc":"See  PipetteElixir.Result.sequence/1 .","ref":"PipetteElixir.html#sequence/1"},{"type":"function","title":"PipetteElixir.traverse/2","doc":"See  PipetteElixir.Result.traverse/2 .","ref":"PipetteElixir.html#traverse/2"},{"type":"function","title":"PipetteElixir.with_default/2","doc":"See  PipetteElixir.Result.with_default/2 .","ref":"PipetteElixir.html#with_default/2"},{"type":"module","title":"PipetteElixir.Control","doc":"Pipe control combinators.","ref":"PipetteElixir.Control.html"},{"type":"function","title":"PipetteElixir.Control.dbg_when/2","doc":"Pipe-friendly dbg/1 wrapper controlled by a predicate.\n\n    value |> dbg_when(Mix.env() == :dev)","ref":"PipetteElixir.Control.html#dbg_when/2"},{"type":"function","title":"PipetteElixir.Control.do_tap/2","doc":"Run `fun.(value)` without changing the value.","ref":"PipetteElixir.Control.html#do_tap/2"},{"type":"macro","title":"PipetteElixir.Control.pipe_case/2","doc":"Pattern-match inside a pipeline while keeping it flowing.\n\n    user\n    |> pipe_case do\n         %{email: e} -> String.downcase(e)\n         _           -> nil\n       end","ref":"PipetteElixir.Control.html#pipe_case/2"},{"type":"function","title":"PipetteElixir.Control.pipe_unless/3","doc":"Inverse of pipe_when.","ref":"PipetteElixir.Control.html#pipe_unless/3"},{"type":"function","title":"PipetteElixir.Control.pipe_when/3","doc":"If cond truthy, apply fun; else pass through.","ref":"PipetteElixir.Control.html#pipe_when/3"},{"type":"module","title":"PipetteElixir.Deep","doc":"Deep data manipulation with paths and wildcards.","ref":"PipetteElixir.Deep.html"},{"type":"function","title":"PipetteElixir.Deep.dig_get/3","doc":"","ref":"PipetteElixir.Deep.html#dig_get/3"},{"type":"function","title":"PipetteElixir.Deep.dig_pop/2","doc":"","ref":"PipetteElixir.Deep.html#dig_pop/2"},{"type":"function","title":"PipetteElixir.Deep.dig_put/3","doc":"","ref":"PipetteElixir.Deep.html#dig_put/3"},{"type":"function","title":"PipetteElixir.Deep.dig_update/3","doc":"","ref":"PipetteElixir.Deep.html#dig_update/3"},{"type":"type","title":"PipetteElixir.Deep.path/0","doc":"","ref":"PipetteElixir.Deep.html#t:path/0"},{"type":"module","title":"PipetteElixir.Parallel","doc":"Bounded parallelism that feels like Enum.","ref":"PipetteElixir.Parallel.html"},{"type":"function","title":"PipetteElixir.Parallel.pfilter/3","doc":"Parallel filter via mapper that returns boolean.","ref":"PipetteElixir.Parallel.html#pfilter/3"},{"type":"function","title":"PipetteElixir.Parallel.pmap/3","doc":"","ref":"PipetteElixir.Parallel.html#pmap/3"},{"type":"type","title":"PipetteElixir.Parallel.pmap_opt/0","doc":"","ref":"PipetteElixir.Parallel.html#t:pmap_opt/0"},{"type":"function","title":"PipetteElixir.Parallel.pmap_reduce/5","doc":"Parallel reduce. Order-insensitive by default.","ref":"PipetteElixir.Parallel.html#pmap_reduce/5"},{"type":"module","title":"PipetteElixir.Path","doc":"Path representation and sigil.","ref":"PipetteElixir.Path.html"},{"type":"function","title":"PipetteElixir.Path.parse/1","doc":"Parses a slash path string into a list of segments.","ref":"PipetteElixir.Path.html#parse/1"},{"type":"type","title":"PipetteElixir.Path.segment/0","doc":"","ref":"PipetteElixir.Path.html#t:segment/0"},{"type":"macro","title":"PipetteElixir.Path.sigil_p/2","doc":"~p sigil parses a slash path:\n\n    ~p\"/users/*/email\"  #=> [:users, :*, :email]\n    ~p\"/items/0/id\"     #=> [:items, 0, :id]","ref":"PipetteElixir.Path.html#sigil_p/2"},{"type":"type","title":"PipetteElixir.Path.t/0","doc":"","ref":"PipetteElixir.Path.html#t:t/0"},{"type":"module","title":"PipetteElixir.Result","doc":"Result helpers for {:ok, _} / {:error, _} flows.","ref":"PipetteElixir.Result.html"},{"type":"function","title":"PipetteElixir.Result.bind/2","doc":"Monadic bind/and_then.","ref":"PipetteElixir.Result.html#bind/2"},{"type":"function","title":"PipetteElixir.Result.error/1","doc":"","ref":"PipetteElixir.Result.html#error/1"},{"type":"function","title":"PipetteElixir.Result.map_error/2","doc":"Map error value; leave ok untouched.","ref":"PipetteElixir.Result.html#map_error/2"},{"type":"function","title":"PipetteElixir.Result.map_ok/2","doc":"Map ok value; leave error untouched.","ref":"PipetteElixir.Result.html#map_ok/2"},{"type":"function","title":"PipetteElixir.Result.ok/1","doc":"","ref":"PipetteElixir.Result.html#ok/1"},{"type":"function","title":"PipetteElixir.Result.presence/2","doc":"Convert nil/blank to error; pass through non-nil as {:ok, value}.","ref":"PipetteElixir.Result.html#presence/2"},{"type":"type","title":"PipetteElixir.Result.result/1","doc":"","ref":"PipetteElixir.Result.html#t:result/1"},{"type":"function","title":"PipetteElixir.Result.sequence/1","doc":"Sequence a list of results -> result of list.","ref":"PipetteElixir.Result.html#sequence/1"},{"type":"function","title":"PipetteElixir.Result.traverse/2","doc":"Traverse enum with f returning result.","ref":"PipetteElixir.Result.html#traverse/2"},{"type":"function","title":"PipetteElixir.Result.with_default/2","doc":"Provide a default when error.","ref":"PipetteElixir.Result.html#with_default/2"},{"type":"extras","title":"Pipette","doc":"# Pipette\n\n**Pipette** is a collection of pipeline-first utilities designed to enhance the ergonomics and expressiveness of data transformations in Elixir. It provides a focused set of tools that seamlessly integrate into `|>` pipelines, making your code more readable, maintainable, and robust.","ref":"readme.html"},{"type":"extras","title":"Philosophy - Pipette","doc":"**Goal**: To provide ergonomic helpers that naturally fit into `|>` pipelines, simplifying common Elixir programming patterns. Pipette aims to solve specific problems related to data flow, error handling, and controlled parallelism within a pipeline context.\n\n**Non-goals**: Pipette does not aim to reimplement the extensive functionalities of `Enum` or `Stream` modules, nor is it intended to be a general-purpose collection of random helpers. Its scope is intentionally narrow to ensure high utility and seamless integration within pipelines.","ref":"readme.html#philosophy"},{"type":"extras","title":"Core Principles - Pipette","doc":"Pipette is built upon four core principles, each addressing a key aspect of efficient and robust Elixir pipelines:\n\n1.  **Pipe Control Combinators**: Utilities that allow for dynamic control and manipulation of the pipeline's flow, enabling conditional execution, early exits, and more expressive data routing.\n2.  **Result/Maybe Flow**: Tools for managing and propagating success and failure states within pipelines, promoting clear error handling and reducing boilerplate for `{:ok, value}` and `{:error, reason}` patterns.\n3.  **Deep Data Paths**: Convenient mechanisms for safely accessing and transforming deeply nested data structures, reducing the verbosity often associated with complex map or struct manipulations.\n4.  **Bounded Parallelism**: Functions that enable controlled parallel execution within pipelines, offering performance benefits for I/O-bound operations while maintaining a familiar `Enum`-like interface.","ref":"readme.html#core-principles"},{"type":"extras","title":"Installation - Pipette","doc":"Add `pipette` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:\"pipette-elixir\", \"~> 0.1.1\"}\n  ]\nend\n```","ref":"readme.html#installation"},{"type":"extras","title":"Usage - Pipette","doc":"Pipette provides a set of powerful functions that integrate directly into your Elixir pipelines. Here are a few examples demonstrating its capabilities:\n\n```elixir\nimport PipetteElixir\nimport PipetteElixir.Path, only: [sigil_p: 2]\n\n# Form validation: Safely extract, validate, and transform user input.\n# This example demonstrates using `dig_get` for deep data access,\n# `presence` for basic validation, and `bind`/`map_ok` for chaining\n# operations that might return success or error tuples.\nparams\n|> dig_get(~p\"/email\")\n|> presence(:missing_email)\n|> bind(&validate_email/1)\n|> bind(&normalize_email/1)\n|> map_ok(&%{email: &1})\n\n# Parallel API calls: Efficiently fetch data from multiple sources in parallel.\n# `pmap` allows for concurrent execution with a configurable maximum concurrency,\n# while `pfilter` enables parallel filtering of results.\nuser_ids\n|> pmap(&Users.fetch!/1, max_concurrency: 32, ordered: false)\n|> pfilter(& &1.active)\n|> Enum.map(& &1.email)\n```","ref":"readme.html#usage"},{"type":"extras","title":"Why Pipette? - Pipette","doc":"Pipette helps you write cleaner, more functional Elixir code by:\n\n*   **Improving Readability**: By keeping operations within the pipeline, the flow of data is clear and easy to follow.\n*   **Enhancing Error Handling**: Explicitly managing success and error states within the pipeline reduces the need for nested `case` statements.\n*   **Simplifying Data Access**: Safely navigate and modify complex data structures with concise path-based operations.\n*   **Optimizing Performance**: Leverage controlled parallelism for I/O-bound tasks without sacrificing code clarity.","ref":"readme.html#why-pipette"},{"type":"extras","title":"Documentation - Pipette","doc":"Full documentation, including a comprehensive API reference and additional examples, can be found at [https://hexdocs.pm/pipette](https://hexdocs.pm/pipette).","ref":"readme.html#documentation"},{"type":"extras","title":"Source Code - Pipette","doc":"The source code for Pipette is available on GitHub: [https://github.com/alexzzzs/pipette](https://github.com/alexzzzs/pipette)","ref":"readme.html#source-code"},{"type":"extras","title":"Contributing - Pipette","doc":"We welcome contributions to Pipette! If you have a feature request, bug report, or would like to contribute code, please refer to the project's GitHub repository for guidelines and issue tracking.","ref":"readme.html#contributing"},{"type":"extras","title":"Changelog","doc":"# Changelog","ref":"changelog.html"},{"type":"extras","title":"v0.1.0 - Changelog","doc":"Initial release.\n\n*   `Pipette.Control`: `tap/2`, `pipe_when/3`, `pipe_unless/3`, `pipe_case/2`, `dbg_when/2`\n*   `Pipette.Result`: `ok/1`, `error/1`, `presence/2`, `bind/2`, `map_ok/2`, `map_error/2`, `with_default/2`, `sequence/1`, `traverse/2`\n*   `Pipette.Deep`: `dig_get/3`, `dig_put/3`, `dig_update/3`, `dig_pop/2`\n*   `Pipette.Path`: `~p` sigil\n*   `Pipette.Parallel`: `pmap/3`, `pmap_reduce/5`, `pfilter/3`","ref":"changelog.html#v0-1-0"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}